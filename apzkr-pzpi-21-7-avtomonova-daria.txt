Міністерство освіти і науки України
Харківський національний університет радіоелектроніки

Факультет комп’ютерних наук

Кафедра програмної інженерії

КУРСОВА РОБОТА
ПОЯСНЮВАЛЬНА ЗАПИСКА
з навчальної дисципліни «Архітектура програмного забезпечення»
Тема роботи: Програмна система організації та керування мережею фітнес клубів, басейнів

Студентка гр. ПЗПІ-21-7	_________________Автомонова Д.С.
(підпис)
Керівник роботи	____________ст.викл. Сокорчук І.П.
(підпис)
	Роботу захищено «__»_____2024р.
3 оцінкою_____________________
Комісія:	____________доц. Лещинський В.О.
(підпис)
	______________доц. Лещинська І.О.
(підпис)
	____________ст.викл. Сокорчук І.П.
(підпис)

Харків
2024 р.
Харківський національний університет радіоелектроніки  
  
Факультет комп’ютерних наук 	 	 Кафедра програмної інженерії          
Спеціальність 121 – Інженерія програмного забезпечення     	  	  	         
Курс     	3   	   Семестр    	 	6  	  	 	  	          
Навчальна дисципліна Архітектура програмного забезпечення                     

ЗАВДАННЯ  
НА КУРСОВУ РОБОТУ СТУДЕНТОВІ   

   	  	  	           Автомоновій Дар’ї Сергіївні 	  	          	  	          
1.	Тема проєкту: «Програмна система організації та керування мережею фітнес клубів, басейнів»	  	                                          	        
2.	Термін узгодження завдання з курсової роботи: «25» березня  2024 р.
3.	Термін здачі студентом закінченої роботи: «    »                         2024 р.
4.	Вихідні дані до проєкту: в програмній системі передбачити: додавання, редагування та видалення клубів, користувачів, залів, абонементів, ведення статистики відвідувань, використовувати OC Windows 10, СКБД MongoDB,  середовище розробки JetBrains WebStorm. 	
5.	Зміст пояснювальної записки (перелік питань, що належить розробити): вступ, аналіз предметної області, постановка задачі, проектування програмного проекту, структура бази даних, кодування програмного проекту, опис розробленої програмної системи, висновки, перелік посилань, додатки	  	  	  	  	  	  	  	                                      
6.	Перелік графічного матеріалу (з точним зображенням обов’язкових креслень): схема бази даних, діаграма варіантів використання, діаграма розгортання, інтерфейс головної сторінки  	  	  	  	
КАЛЕНДАРНИЙ ПЛАН


№ 	Назви етапів курсової роботи 	Термін виконання етапів роботи	Примітка
1 	Функціональна специфікація
програмного проєкту	25.03.2023	 виконано
2 	Проектування програмного
проєкту	10.04.2024	 виконано
3 	Кодування програмного проєкту	30.04.2024	 виконано
4 	Оформлення пояснювальної
записки	25.05.2024	 виконано
5 	 Захист курсової роботи		 не виконано

Дата видачі теми проєкту «13» березня 2024 р.  
Керівник		_________ ст. викл. Сокорчук І.П.
(підпис)

Завдання прийняв до виконання
ст.гр. ПЗПІ-21-7	_________ Автомонова Д.С.
(підпис)

 
РЕФЕРАТ


Пояснювальна записка до курсової роботи: х с., х рис., х табл., х додатків, х джерел.
ФІТНЕС КЛУБИ, БАСЕЙН, АБОНЕМЕНТ, ВІДВІДУВАННЯ, ТРЕНАЖЕРНІ ЗАЛИ, МЕРЕЖА ТРЕНАЖЕРНИХ ЗАЛІВ.

Об’єктом дослідження є сегмент індустрії здоров’я та фітнесу, а саме організацію та керування місцями, де люди можуть займатися фізичними вправами, використовувати тренажери та брати участь у групових заняттях.
Метою курсової роботи є розробка системи організації та керування мережею фітнес клубів та басейнів, що надає можливість купувати абонементи для відвідування тренажерних залів, відстежувати свої відвідування та історію покупок, створювати власні мережі залів, редагувати, видаляти їх, а також створювати,  редагувати та видаляти зали, абонементи, та відстежувати відвідування своїх залів, а також генерувати QR-код та зчитувати його, під час відвідування користувачем тренажерного залу. Це оновлює історію відвідувань користувача, а також статистичні дані певного залу.
Методи розробки базуються на платформі Node.js з використанням мови програмування Javascript, фреймворку express.js та базі даних MongoDB. Веб-застосунок базується на бібліотеці React з мовою програмування Javascript, смарт-пристрій розроблено на технології Node-RED.
У результаті роботи здійснено програмну реалізацію системи організації та керування мережею фітнес клубів та басейнів. Програмна система складається з веб-додатку, сервера та смарт-пристрою.


ЗМІСТ


ВСТУП	7
1 АНАЛІЗ ПРЕДМЕТНОЇ ОБЛАСТІ	8
1.1	Бізнес-вимоги	8
1.1.1	Бізнес можливості	8
1.1.2 Бізнес-цілі та критерії успіху	9
1.1.3 Потреби клієнтів або ринку	9
1.1.4 Бізнес-ризики	10
1.2	Концепція рішення	11
1.2.1	Окреслення концепції	11
1.2.2	Головна функціональність	12
1.2.3	Припущення та залежності	13
1.3	Рамки та обмеження проєкту	14
1.3.1	Рамки первинного випуску	14
1.3.2 Рамки наступних випусків	16
1.3.3 Обмеження та винятки	17
1.4 Бізнес-контекст	18
1.4.1 Профілі зацікавлених сторін	18
1.4.2 Пріорітети проекту	19
1.4.3 Робоче середовище	20
2	ПОСТАНОВКА ЗАДАЧІ	22
3 ПРОЄКТУВАННЯ ТА АРХІТЕКТУРА ПРОГРАМНОЇ СИСТЕМИ	23
3.1 Проєктування серверної частини	23
3.1.1 Моделювання програмної системи	23
3.1.2 Проєктування бази даних	24
3.1.3 Технології та архітектурні рішення	26
3.1.4 Специфікація REST	27
3.2 Проектування програмної частини смарт-пристрою	30
3.2.1 Моделювання частини програмної системи смарт-пристрою	30
3.2.2 Побудова діаграми взаємодії для смарт-пристрою	31
3.2.3 Побудова діаграми діяльності смарт-пристрою	32
3.2.4 Побудова діаграми пакетів	33
3.2.5 Розробка частини смарт-пристрою	34
3.3 Проєктування клієнтської частини програмної системи	35
3.3.1 Побудова діаграми компонентів	35
3.3.2 Побудова діаграми пакетів	36
3.3.3 Побудова діаграми станів	37
3.3.4 Розробка клієнтської частини	39
4 ОПИС ПРОГРАМНОЇ СИСТЕМИ	40
4.1 Запуск застосунку	40
4.2 Опис програмної реалізації для користувача	42
4.3 Опис програмної реалізації для адміністратора	53
ВИСНОВКИ	60
ПЕРЕЛІК ДЖЕРЕЛ ПОСИЛАННЯ	61
ДОДАТОК А	62
ДОДАТОК Б	73
ДОДАТОК В	78

 
ВСТУП


Предметна область - управління мережею фітнес-клубів та басейнів - охоплює широкий спектр аспектів, пов'язаних з організацією, функціонуванням і розвитком закладів фітнесу та рекреації.
Сучасна культура здорового способу життя спричинила великий попит на послуги фітнесу та рекреації. З цього випливає зростання кількості фітнес-клубів та басейнів у багатьох містах. Проте, це призводить до збільшення конкуренції та необхідності для власників підтримувати високий рівень сервісу та ефективно управляти своїми закладами.
Збільшення кількості клієнтів та їхніх різних потреб ставить під сумнів ефективність традиційних методів управління. Відстеження абонементів, розкладів занять, спеціальних запитів та інших аспектів вимагає систематизації та автоматизації.
Ефективне управління фінансами стає складнішим зі зростанням розміру бізнесу. Облік оплати абонементів, послуг, оплати персоналу та інших витрат вимагає точності та системності.
Організація розкладу занять та обслуговування клієнтів вимагає уважного планування та координації. Важливо забезпечити рівномірне навантаження на тренерський склад та уникнути переповнення або нестатку учасників.
Конкуренція у сфері фітнесу дедалі зростає, і важливо виробляти стратегії привертання та утримання клієнтів, а також розвивати інноваційні підходи до просування своєї мережі фітнес-клубів та басейнів.
Ці проблеми демонструють потребу в комплексному рішенні - програмній системі, яка забезпечить ефективне управління всіма аспектами бізнесу фітнесу та рекреації.
 
1 АНАЛІЗ ПРЕДМЕТНОЇ ОБЛАСТІ
1.1	Бізнес-вимоги
1.1.1	Бізнес можливості


На ринку існує кілька аналогічних програмних рішень для управління мережею фітнес-клубів та басейнів. Розглянемо деякі з них та їхні переваги та недоліки.
Mindbody - це одна з найпопулярніших платформ для управління клубами фітнесу. Mindbody надає широкий спектр функцій, включаючи реєстрацію клієнтів, планування розкладів, облік фінансів та інші. Переваги включають велику функціональність та інтеграцію з різними платформами, але може бути складним у використанні та дорогим для деяких клубів.
Club OS - це програмне рішення, спеціалізоване на управлінні фітнес-клубами. Club OS надає інструменти для ефективного управління клієнтською базою, створення та відстеження продажів, а також аналітичні засоби для вироблення стратегічних рішень. Перевагою є простота використання та гнучкість, але інтеграція з іншими системами може бути обмеженою.
Perfect Gym пропонує комплексне рішення для фітнес-клубів, включаючи управління клієнтами, розкладами, фінансами, а також онлайн-бронювання та оплату послуг. Перевагами є широкий функціонал та інтеграція з різними системами, але може бути відносно дорогим для деяких бізнесів.
Наша програмна система відзначається такими особливостями та перевагами:
‒	Наше програмне рішення буде мати широкий спектр функцій, які можна настроювати відповідно до потреб конкретного клубу чи басейну, забезпечуючи гнучкість.
‒	Інтуїтивно зрозумілий інтерфейс, який дозволить адміністраторам та персоналу швидко оволодіти системою.
‒	Наша система надає детальні звіти та аналітику, які допоможуть власникам та менеджерам клубів приймати обґрунтовані рішення для вдосконалення бізнесу, виявлення трендів та визначення ефективності різних ініціатив.


1.1.2 Бізнес-цілі та критерії успіху


BO-1: Глобальне впровадження: Запуск системи у двох країнах протягом перших шести місяців з високим рівнем задоволення користувачів.
BO-2: Збільшення продажів: Збільшити обсяг продажів абонементів та додаткових послуг на 20%.
BO-3: Оптимізація витрат: Оптимізувати витрати та підвищити ефективність управління ресурсами клубів та басейнів.
SC-1: Висока участь користувачів: Зареєструвати не менше 50 000 користувачів протягом перших трьох місяців роботи системи.
SC-2: Задоволеність користувачів: Не менше ніж 90% користувачів позитивно оцінують зручність та ефективність системи на основі регулярних опитувань.
SC-3: Інтеграція з іншими системами: Забезпечення сумісності з системами безпеки, управління будівлею та іншими технологічними рішеннями, що використовуються.


1.1.3 Потреби клієнтів або ринку


Види користувачів: бізнес та клієнт.

Потребами для клієнтів є:
–	зручний доступ до розкладів занять та тренувань через мобільний додаток або веб-сайт клубу;
–	можливість онлайн-бронювання місць на заняттях та басейнових сеансах;
–	огляд свого фінансового стану, абонементів та акцій через особистий кабінет;
–	отримання сповіщень про зміни в розкладі, нові послуги та акції для підтримки та мотивації.

Потребами для бізнесу є:
‒	можливість реєстрації нових клієнтів, відстеження їхньої активності та історії відвідувань.
‒	автоматизоване планування розкладів занять та тренувань для оптимізації використання ресурсів клубу або басейну.
‒	ефективний фінансовий облік, тобто можливість ведення обліку абонементів, оплати послуг, заробітної плати працівників та інших фінансових операцій.
‒	можливість отримувати звіти про ефективність роботи клубу, фінансовий стан та інші ключові показники для прийняття обґрунтованих рішень.


1.1.4 Бізнес-ризики


Ризики:
‒	введення програмної системи може стикнутися з технічними проблемами, такими як збої в роботі програмного забезпечення, проблеми з безпекою даних або недоліки в системі. Це може призвести до втрати даних, негативного впливу на репутацію бренду та втрати витрат на виправлення проблем;
‒	існує ризик того, що бізнес може недооцінити потреби своїх клієнтів або персоналу під час розробки програмної системи. Це може призвести до недостатньої функціональності або неприйняття користувачами нової системи;
‒	недостатня захищеність бази даних може призвести до витоку конфіденційної інформації про клієнтів або компанії, що може вразити репутацію бренду та призвести до правових проблем.

Можливі дії:
‒	здійснення регулярних тестів програмної системи, а також аудиту безпеки даних для виявлення та усунення можливих проблем ще на етапі розробки;
‒	активна взаємодія з потенційними користувачами під час розробки системи для визначення їхніх потреб та вимог. Проведення тестувань і збирання фідбеку для забезпечення того, що система відповідає їхнім очікуванням;
провадження заходів з посилення безпеки даних, таких як шифрування, багаторівневий контроль доступу та регулярне оновлення захисних механізмів. Також важливо надавати навчання персоналу щодо правильної обробки та зберігання конфіденційної інформації.


1.2	Концепція рішення 
1.2.1	Окреслення концепції


Система  призначена для забезпечення ефективного управління мережею фітнес-клубів та басейнів. Основна мета полягає в наданні інструментів для оптимізації ділових процесів, забезпечення зручності для користувачів та підвищення ефективності управління ресурсами.
Система має забезпечувати зручний доступ до інформації про клієнтів, їхні абонементи, розклади відвідувань та історію платежів.
Система повинна допомагати в оптимізації розкладів занять, враховуючи доступні тренери, зони, обладнання та популярність занять.
Система має забезпечувати контроль над фінансами клубів, включаючи оплату абонементів, послуг та заробітну плату персоналу, а також надавати звіти та аналітику для прийняття обґрунтованих управлінських рішень.
Система повинна надавати клієнтам зручний доступ до розкладів занять та інформації про абонементи через мобільний додаток або веб-сайт.
Важливо, щоб система забезпечувала високий рівень безпеки для захисту конфіденційної інформації клієнтів та даних компанії від несанкціонованого доступу та витоків.
Система повинна бути здатна інтегруватися з існуючими системами бізнесу, такими як бухгалтерська звітність, електронні платіжні системи та інші, для забезпечення гладкого обміну даними та уникнення подвійного введення інформації.
Система прагне стати надійним інструментом для власників та менеджерів фітнес-клубів та басейнів, що допоможе їм оптимізувати робочі процеси, підвищити ефективність та задоволеність клієнтів, а також забезпечити стійкий розвиток свого бізнесу.


1.2.2	Головна функціональність


MF-1: Збереження основних даних про клієнтів, включаючи контактну інформацію, історію платежів та відвідувань.
MF-2: Можливість створення і керування різними типами абонементів та послуг для клієнтів.
MF-3: Створення графіків занять для різних груп тренувань, тренерів та зон клубу або басейну. Автоматичне оновлення розкладу з урахуванням змін у доступності тренерів та зон.
MF-4: Збереження фінансової інформації про витрати та доходи клубу або басейну. Підготовка звітів та аналітики щодо фінансового стану та ефективності роботи.
MF-5: Користувачі можуть користуватися застосунком англійською й українською мовами.
MF-6: Інтеграція різних методів оплати, включаючи кредитні картки, електронні гроші та інші способи оплати.
MF-7: Онлайн-реєстрація нових клієнтів та оформлення абонементів.
MF-8: Захист конфіденційної інформації клієнтів та даних компанії від несанкціонованого доступу. Керування рівнями доступу для різних користувачів системи.


1.2.3	Припущення та залежності


П-1. Припускається, що клієнти мають достатній рівень технічної готовності для користування системою, включаючи доступ до Інтернету та сумісність з пристроями.
П-2. Припускається, що постачальники іншого програмного забезпечення чи послуг будуть готові до інтеграції з нашою системою та надаватимуть необхідну підтримку.
П-3. Система має відповідні заходи безпеки для захисту від вірусів, шкідливих програм і потенційних кібератак.
П-4: Інтерфейс користувача системи є зрозумілим і зручним для ефективного користування.
З-1. Успішна інтеграція нашої системи може залежати від доступності та сумісності з існуючими системами бізнесу клієнта, такими як бухгалтерська програма або система керування відносинами з клієнтами.
З-2. Впровадження системи може залежати від доступності необхідних людських, фінансових та матеріальних ресурсів для виконання проекту.
З-3. Залежність від можливості масштабування інфраструктури системи для адаптації до збільшення об'єму даних чи кількості пристроїв.
З-4. Залежність від наявності механізмів для оновлення та підтримки програмного забезпечення системи з плином часу.


1.3	Рамки та обмеження проєкту
1.3.1	Рамки первинного випуску


Програмна система включає в себе чотири частини: Back-end, IoT, Front-end та мобільний застосунок.

Серверна частина (Back-end):
–	реєстрація користувачів: реєстрація нових користувачів з використанням основних особистих даних;
–	авторизація користувачів: авторизація користувачів через ідентифікатори або паролі;
–	управління клієнтською базою: зручний доступ до інформації про клієнтів, їхні абонементи, розклади відвідувань та історію платежів;
–	планування ресурсів та розкладів: оптимізації розкладів занять, враховуючи доступні тренери, зони, обладнання та популярність занять;
–	інтеграція платіжних систем: інтеграція з платіжними системами для оплати користувачами абонементів;
–	відображення виплат: відображення історії виплат та стану рахунку;
–	онлайн оплата абонементу: онлайн-бронювання місць та покупка абонементів через мобільний додаток або веб-сайт.

IoT частина:
–	RFID та NFC датчики: використання датчиків для сканування абонементів користувачів, для подальшої взаємодії з їх обліковими записами та відстеження відвідуваності.
–	збір даних: збір та передача даних в реальному часі до центральної системи через мережу;
–	Wi-Fi-модуль: використання Wi-Fi-модуля для підключення системи до мережі Інтернет, що дозволяє взаємодію із серверами та збереженням даних в хмарі.

Клієнтська частина (Front-end):
–	реєстрація та вхід користувачів: сторінки авторизації та реєстрації;
–	локалізація: можливості вибору мови (української та англійської) для користувачів;
–	інтерфейс адміністраторів: інтерфейс для адміністраторів системи для управління користувачами, даними та іншими параметрами системи;
–	відображення даних про розклад: створення інтерфейсу для відображення даних про розклад занять;
–	інтеграція платіжних систем: створення інтерфейсу для інтеграції з платіжними системами для оплати користувачами послуг;
–	інтерфейс для покупки абонементу онлайн.

1.3.2 Рамки наступних випусків


В майбутньому проект буде масштабуватися та буде впроваджено новий функціонал.

Серверна частина (Back-end):
–	представлення адміністраторам звітів та графіків для ефективного моніторингу;
–	підтримка нових методів оплати та розширення функціоналу для зручного використання;
–	виявлення трендів та планування стратегій розвитку на основі аналізу даних;
–	додавання аналітичних інструментів для більш глибокого аналізу даних про користувачів. 

IoT частина:
–	додавання підтримки інших мережевих протоколів для забезпечення більшої сумісності з різними IoT-пристроями;
–	збір даних про час та інтенсивність використання фітнес-обладнання для оцінки його ефективності та популярності серед користувачів.

Клієнтська частина (Front-end):
–	додавання інструментів для масового управління користувачами та їхніми налаштуваннями.;
–	вдосконалення взаємодії з графіками та звітами для забезпечення зручності користування;
–	розширення можливостей налаштування інтерфейсу для кожного користувача.

1.3.3 Обмеження та винятки


Обмеження:
–	Необхідність доступу до Інтернету: Для коректної роботи системи необхідний стабільний доступ до Інтернету. Відсутність з'єднання або його низька якість може обмежити функціональність системи;
–	Сумісність з платформами: Деякі функції системи можуть бути обмежені через сумісність з операційними системами або пристроями, які використовуються користувачами;
–	Обмеження щодо старого обладнання: Система може не повністю підтримувати інтеграцію зі старим або застарілим обладнанням, що може обмежити можливості використання деяких функцій.
–	Надійність мережі даних: Система залежить від стабільної та безпечної мережі даних для обміну інформацією в реальному часі.

Винятки:
–	Специфічні вимоги клієнтів: У випадку специфічних потреб або вимог клієнтів, можуть бути зроблені винятки щодо функціональності системи або проведені налаштування для задоволення конкретних потреб;
–	Початкове калібрування та налаштування: Проблеми, що виникають внаслідок неправильної установки, калібрування або початкового налаштування, не покриваються стандартним програмним пакетом;
–	Критичні ситуації: У випадках критичних ситуацій, таких як аварійні ситуації чи важливі потреби користувачів, можуть бути зроблені винятки щодо обмежень системи з метою забезпечення безперебійного функціонування.
–	Зміни у законодавстві: Винятком можуть бути випадки, коли необхідно адаптувати систему до змін у законодавстві або регулятивних вимогах, що може вимагати внесення змін або доповнень до функціональності.
1.4 Бізнес-контекст 
1.4.1 Профілі зацікавлених сторін


Профілі зацікавлених сторін проекту наведені в таблиці 1.1.

Таблиця 1.1 – Профілі зацікавлених сторін проєкту
Зацікавлена сторона	Головна цінність	Ставлення	Головні інтереси	Обмеження
Бізнес	Оптимізація витрат та ефективність обслуговування користувачів.	Інтерес в підвищенні прибутковості за рахунок оптимізації ресурсів.	Збільшення прибутковості, збільшення ефективності робочого дня за допомогою автоматично складених розкладів.	Обмежені фінансові ресурси для впровадження системи, можливі технічні обмеження.
Користувачі системи	Зручність та надійність онлайн бронювань та покупок абонементів.	Очікування зручного та ефективного користування системою.	Забезпечення зручності та ефективності за допомогою отримання аналітичних даних.	Можливість неприйняття нової технології або необхідність навчання користувачів.
Розробник проєкту	Розробка та підтримка програмного продукту.	Інтерес в створенні ефективної та надійної програмної системи.	Удосконалення та підтримка програмного продукту для максимальної ефективності.	Обмежені терміни розробки та ресурси.
Інвестори	Зростання вартості інвестицій, прибуток.	Очікування високої рентабельності інвестицій.	Збільшення вартості інвестицій та отримання прибутку.	Фінансові ризики, можливість затримок у реалізації проекту.


1.4.2 Пріорітети проекту


Пріоритети проєкту наведені в таблиці 1.2.

Таблиця 1.2 – Пріоритети проєкту
Показник	Виконання (етапи)	Обмеження (граничні значення)	Ступінь свободи (допустимий діапазон)
План робіт	Проєкт має бути реалізований до 08.06.2024		Можливе відхилення від графіку на 1 місяць

Функціональність			75% функціоналу має працювати на релізі 1.0
Якість			У релізі 1.0 повинні пройти 100% тестувань
Персонал		Максимальний розмір команди – один розробник та тестувальник	
Ціна		7500 гривень	Допустиме відхилення на 15-20%


1.4.3 Робоче середовище


Програмна система організації та керування мережею фітнес клубів, басейнів  буде розгорнута на хмарних сервісах Amazon Web Services (AWS) для забезпечення безперервного доступу користувачів з будь-якої країни. Система буде орієнтована на глобальний ринок, тому важливо мати надійну та ефективну хмарну інфраструктуру.
Для розширення доступності також буде додана локалізація (для української та англійської мов).
Дані будуть зберігатися в базі даних MongoDB. Це NoSQL база даних, яка добре підходить для зберігання великої кількості неструктурованих даних.
Використання Node.js для створення серверної частини дозволить забезпечити високу продуктивність і швидкість обробки запитів. Express.js може використовуватися як веб-фреймворк для зручного створення API та маршрутизації. Середовищем розробки буде Webstorm.
Захист даних користувачів повинен бути забезпечений згідно GDPR.
Буде використано Arduino як RFID та NFC датчики для сканування абонементів користувачів. Датчики будуть запрограмовані з використанням мови програмування C++ за допомогою Arduino IDE.
Для розробки веб-застосунку буде використано бібліотеку React.js. Середовищем розробки буде WebStorm.
Для розробки мобільної частини буде використано мову програмування Kotlin. Середовищем розробки буде IntelliJ IDEA або Android Studio.
 
2	ПОСТАНОВКА ЗАДАЧІ


Згідно з аналізом предметної області та завданням курсової роботи було визначено створення програмної системи для організації та керування мережею фітнес клубів та басейнів.
База даних повинна включати інформацію про: користувачів, мережі залів, тренажерні зали, абонементи, покупки, відвідування, тренажери та QR-коди.
Для клієнта має бути реалізований наступний функціонал:
–	Реєстрація, авторизація та вхід у систему;
–	Перегляд доступних мереж тренажерних залів;
–	Перегляд залів певної мережі;
–	Перегляд та редагування власного профілю;
–	Перегляд доступних абонементів певного залу;
–	Купівля абонементу;
–	Перегляд історії покупок;
–	Перегляд відвідувань залів;
–	Експорт історії покупок та абонементів.
Для адміністратора має бути реалізований наступний функціонал:
–	Реєстрація, авторизація та вхід у систему;
–	Створення власної мережі тренажерних залів;
–	Перегляд та редагування власного профілю;
–	Редагування мережі залів;
–	Додавання, редагування та видалення тренажерних залів;
–	Додавання, редагування та видалення абонементів;
–	Додання та видалення тренера;
–	Додання та видалення тренажера;
–	Експорт даних про мережу тренажерних залів.
 
3 ПРОЄКТУВАННЯ ТА АРХІТЕКТУРА ПРОГРАМНОЇ СИСТЕМИ
3.1 Проєктування серверної частини
3.1.1 Моделювання програмної системи


Серед користувачів програмної системи є 3 типи акторів: звичайний відвідувач тренувальних залів (далі відвідувач), адміністратор та тренер. 
Взаємодія акторів та системи представлена на діаграмі прецедентів (див. рис. 3.1).

 
Рисунок 3.1 – Діаграма прецедентів

За діаграмою прецедентів було визначено функціональні вимоги та спосіб взаємодії акторів та програмної системи.
Звичайний користувач, тобто відвідувач тренажерних залів може входити до системи, переглядати усі доступні мережі тренажерних залів, мати свій профіль та можливість його редагувати і видаляти, може придбати абонемент та отримати QR-код.
Адміністратор може створювати свою мережу залів, редагувати її, додавати нові тренажерні зали та редагувати старі, додавати тренерів та абонементи, редагувати їх, а також експортувати дані про свою мережу тренажерних залів.
Тренер може входити до системи, переглядати усі доступні мережі тренажерних залів, мати свій профіль та можливість його редагувати і видаляти.


3.1.2 Проєктування бази даних


З метою проектування бази даних була створена ER-модель даних (див. рис. 3.2), що складається з 8 таблиць: користувачі (User), тренажерні зали (Gym), мережі тренажерних залів (Company), покупки абонементів(Purchase), відвідування тренажерних залів(Visit), абонементи (Subscription), тренажери (Trainer) та QR-коди (QrCode).

 
Рисунок 3.2 – ER-модель даних

Виникли наступні зв’язки між сутностями при проектуванні бази даних:
1. Користувач – Мережа тренажерних залів (один до одного, один користувач може володіти тільки однією мережею тренажерних залів)
2. Користувач – Відвідування (один до багатьох, один користувач може мати декілька відвідувань)
3. Користувач – Покупка (один до багатьох, один користувач може мати декілька покупок абонементів)
4. Користувач – QR-код (один до багатьох, один користувач може мати декілька QR-кодів)
5. Мережа тренажерних залів – Тренажерний зал (один до багатьох, в одній мережі може бути декілька тренажерних залів)
6. Тренажерний зал – Абонемент (один до багатьох, у одного тренажерного залу може бути декілька абонементів)
7. Абонемент – QR-код (один до багатьох, один абонемент може мати декілька QR-кодів)
8. Тренажерний зал – тренажер (один до багатьох, один зал може мати декілька тренажерів)


3.1.3 Технології та архітектурні рішення


Створення серверної частини було реалізовано на Node.js з використанням фреймворку Express.js
Як базу даних було обрано MongoDB, доступ до якої реалізований за допомогою бібліотеки Mongoose, що надає інструменти для валідації, побудови схем даних тощо.
З метою візуалізації використаних технологій було побудовано діаграму розгортання (див. рис. 3.3).

 
Рисунок 3.3 – Діаграма розгортання

3.1.4 Специфікація REST


Програмна система використовує REST API, що складається з 29 кінцевих точок, кожен з яких надає певну інформація, як користувачу, так і адміністратору, та виконує бізнес логіку. Специфікація REST API наведена у таблиці 3.1.


Таблиця 3.1 – Специфікація REST API
Посилання на ендпоінт	Метод HTTP	Необхідна роль	Опис роботи
/register	POST	-	Реєстрація користувача
/login	POST	-	Авторизація користувача
/user/:id	GET	user	Отримання даних профілю авторизованого користувача
/user/:id	PUT	user	Редагування даних профілю користувача
/user/:id	DELETE	user	Видалення профілю користувача
/user/:userId/addCard	POST	user	Додання картки користувача для оплати
/user/:id/change-password	PUT	user	Зміна паролю користувача
/user/sub	POST	user	Придбання абонементу авторизованим користувачем
/visits/company/:companyId	GET	admin	Отримання усіх відвідувань тренажерних залів певної мережі
/trainers	GET		Отримання усіх тренажерів доданих до БД
/trainer	POST	admin	Додання нового тренажеру
/sub/:id	GET		Отримання певного абонементу
/sub/:gymId	POST	admin	Створення нового абонементу для певного залу
/sub/:id	PUT	admin	Редагування певного абонементу
/sub/:id	DELETE	admin	Видалення певного абонементу
/purchase/:id	GET	user	Отримання певної покупки
/purchase	POST	user	Створення нової покупки
/gym/:id	GET		Отримання певного тренажерного залу
/gym	POST	admin	Створення нового тренажерного залу
/gym/:id	PUT	admin	Редагування тренажерного залу
/gym/:id	DELETE	admin	Видалення тренажерного залу
/companies	GET		Отримання усіх створених мереж тренажерних залів
/company/:id/gyms	GET		Отримання усіх залів певної компанії
/company/:id/gym	POST	admin	Додання залу до певної мережі залів
/company/:userId	POST	admin	Створення мережі залів адміністратором
/company/:id	PUT	admin	Редагування мережі залів 
/export-purchase-history/:userId	GET	user	Експорт даних про історію покупок користувача
/subs-info/:userId/export	GET	user	Експорт даних про придбані абонементи користувача
/scanQRCode	POST	user	Сканування QR-code для відвідування залу

У такий спосіб було визначено основні кінцеві точки для HTTP запитів до серверної частини застосунку.


3.2 Проектування програмної частини смарт-пристрою
3.2.1 Моделювання частини програмної системи смарт-пристрою


Програмна система організації та керування мережею фітнес клубів, басейнів має 2 ролі користувачів: звичайний відвідувач тренажерних залів (користувач) та адміністратор.
Взаємодію усіх акторів з програмною системою представлено на діаграмі прецедентів (рис. 3.4).

 
Рисунок 3.4 – Діаграма прецедентів

Таким чином, користувач отримує QR-code при придбанні абонемента, який потім має бути сканований адміністратором для пропуску користувача до залу, а також для внесення його відвідування до бази даних.


3.2.2 Побудова діаграми взаємодії для смарт-пристрою


Для визначення взаємодії IoT девайсу та системи було використано UML діаграму взаємодії (див. рис. 3.5).

 
Рисунок 3.5 – Діаграма взаємодії

Після сканування QR-коду користувача, на сервер потрапляють розшифровані дані, а до відвідувань користувача додається нове, з датою та часом сканування. 


3.2.3 Побудова діаграми діяльності смарт-пристрою


Для визначення процесу використання IOT частини програмного застосунку було побудовано діаграму діяльності (рис. 3.6).

 
Рисунок 3.6 - UML діаграма діяльності

Під час сканування QR-коду, якщо виявляється помилка, виконується спроба знову генерувати QR-код. Якщо сканування успішне, то відбувається розшифрування даних користувача про його дані та дані його абонементу, а також створюється нове відвідування для користувача.


3.2.4 Побудова діаграми пакетів


З метою відображення внутрішньої структури програмної системи була розроблена UML діаграма пакетів (рис. 3.7).

 
Рисунок 3.7 - UML діаграма пакетів

Основний набір - це пакет Node-RED Flow, де визначаються всі взаємодії та логіка системи. У Core Functions містяться функціональні блоки, що виконують основні операції, наприклад, зберігання даних. Dashboard Nodes містить набори вузлів для створення графічного інтерфейсу користувача, використовувані переважно для тестування. У пакеті IoT Device Modules містяться специфічні модулі для різних IoT-пристроїв, які забезпечують взаємодію з реальними сенсорами та пристроями.


3.2.5 Розробка частини смарт-пристрою


Для реалізації IOT частини було інтегровано Node-RED у програмну систему через використання npm.
Для розшифрування QR-коду було використано вузол qrdecode, а запити на сервер реалізовані через вузли http.
Було створено потік даних, що приймав запит на сканування коду. Створено функцію для обробки вхідних даних для їх подальшого розшифрування. Додано функцію для обробки розшифрованих даних та функцію для приведення їх до формату JSON для подальшої участі у http запитах до сервера.
Було створено кінцеву точку для серверної частини, яка зберігала дані у базі даних.


3.3 Проєктування клієнтської частини програмної системи
3.3.1 Побудова діаграми компонентів


З метою проектування клієнтської частини була розроблена UML діаграма компонентів (див. рис. 3.8), що демонструє архітектуру системи та взаємодію її компонентів.

 
Рисунок 3.8 - Діаграма компонентів

Були виділені наступні компоненти:
‒	Subscriptions – Відображення доступних абонементів залу для покупки;
‒	Gyms – Відображення усіх тренажерних залів певної мережі;
‒	QR-code – Відображення QR-code для кожного придбаного абонементу користувача;
‒	ExportSubsInfo – Експорт даних про придбані користувачем підписки;
‒	Visits – Відображення усіх даних про відвідування користувача та оновлення даних про відвідування, шляхом сканування QR-code на вході до залу;
‒	Company – Відображення даних про мережу тренажерних залів та можливість їх редагувати;
‒	ExportCompanyInfo – Експорт даних про компанію. 


3.3.2 Побудова діаграми пакетів


Було виділено пакети, які складають структуру програмної системи, шляхом створення Діаграми пакетів (рис. 3.9).
Основний прошарок пакетів рішення включає такі пакети, як пакет вихідного коду (src), пакет компонентів (components), пакет статичних файлів (assets), пакети зі стилями (styles), пакет зі статичними файлам та точкою входу в систему (public).

 
Рисунок 3.9 – Діаграма пакетів


3.3.3 Побудова діаграми станів


Основні функції та інтерфейси, які надає клієнтська частина, були виділені шляхом створення UML діаграми станів (рис. 3.10).

  
Рисунок 3.10 – Діаграма станів

Було отримано наступні функції та інтерфейси, що надає клієнтська частина:
–	Авторизація: Інтерфейс для авторизація користувача;
–	Реєстрація: Інтерфейс для реєстрації користувача;
–	Профіль: Інтерфейс для відображення даних про користувача, їх редагування, видалення, експорту даних та сканування QR-коду;
–	Управління мережею тренажерних залів: Інтерфейс для редагування мережі залів, самих залів, абонементів та експорту даних;
–	Покупка абонементу: Інтерфейс для перегляду доступних абонементів, придбання абонементу та оновлення історії покупок.
Отримано діаграму станів, що показує поведінку клієнтської частини, що залежить від її поточного стану.
3.3.4 Розробка клієнтської частини


Для розробки клієнтської частини програмної системи було обрано React.js, що використовує мову програмування Javascript.
Клієнтська частина надає графічний інтерфейс для відображення створеної бізнес логіки. 
‒	Відображення доступних мереж тренувальних залів, можливість їх редагування адміністратором, можливість додавати до мережі зали, редагувати їх та видаляти, також є можливість додавати до мережі абонементи, редагувати їх та видаляти.
‒	Відображення профілю користувача, можливість редагувати його, переглядати історію покупок, відвідування користувачем залів, а також експортувати дані про покупку та куплені абонементи.
‒	Експортування даних мережі тренажерних залів. Адміністратору на комп’ютер буде завантажено дані у вигляді excel файлу.
‒	Можливість сканувати QR-code користувача та отримати інформацію про нього та його абонемент та оновити його відвідування.
Відповідно до вимог захисту даних, паролі користувачів не відображаються при перегляді інформації користувачів. Паролі також шифруються, щоб сховати їх для відображення у базі даних. Також при авторизації кожному користувачу генерується його унікальний токен для кожної сесії, що реалізовано за допомогою jwt.
 
4 ОПИС ПРОГРАМНОЇ СИСТЕМИ
4.1 Запуск застосунку


Для запуску застосунку, потрібно завантажити архів з репозиторію. Відкрити завантажені файли у середовищі розробки WebStorm, або будь-якому іншому.
Для запуску серверної частини потрібно запустити файл app.js, після чого у терміналі з’явиться повідомлення про успішний запуск сервера та з’єднання з базою даних (див. рис. 4.1).

 
Рисунок 4.1 – Запуск серверної частини

Далі потрібно запустити клієнтську частину за допомогою команди “npm run start” у терміналі. Для цього переходимо у директорію з клієнтською частиною коду та пишемо вище вказану команду у терміналі. Після чого відкриється сторінка у браузері з програмою (див. рис. 4.2). 

 
Рисунок 4.2 – Запуск клієнтської частини
Далі потрібно запустити частину програмного коду для роботи зі смарт-пристроєм. Для цього потрібно встановити Node-RED. Відкриваємо консольний рядок та вводимо наступну команду «npm install -g --unsafe-perm node-red». Після чого потрібно запустити його за допомогою команди «node-red» (див. рис. 4.3).

 
Рисунок 4.3 – Запуск частини смарт-пристрою

Тепер потрібно перейти за посиланням http://localhost:1880/, та експортувати завантажений файл з репозиторію. Після чого розгорнути отриману систему вузлів (див. рис. 4.4).

 
Рисунок 4.4 – Розгорнута частина смарт-пристрою

Після цього застосунок повністю готовий до роботи. Треба повернутись на сторінку клієнтської частини у браузері та почати роботу.


4.2 Опис програмної реалізації для користувача


При запуску клієнтського застосунку можна побачити головну сторінку, яка містить перелік доступних мереж тренажерних залів та фітнес клубів (див. рис. 4.5).
З головної сторінки можна потрапити на сторінку авторизації та реєстрації, також потрапити на сторінку мережі фітнес клубів та зробити пошук по назві потрібної мережі.

  
Рисунок 4.5 – Головна сторінка

На сторінці авторизації (див. рис. 4.6) можна увійти в систему під власним обліковим записом, або потрапити на сторінку реєстрації для створення нового облікового запису.

 
Рисунок 4.6 – Сторінка авторизації

На сторінці створення нового облікового запису потрібно ввести ім’я нового користувача, його поштову скриньку, пароль та роль (див. рис. 4.7). Після успішної реєстрації користувач потрапить на сторінку авторизації для входження у систему.

 
Рисунок 4.7 – Сторінка реєстрації

Якщо поле заповнене невірно, то користувач отримує наступну помилку (див. рис. 4.8). Наявна валідація на правильне введення поштової скриньки та паролю, що має містити щонайменше 6 символів.

 
Рисунок 4.8 – Помилка реєстрації

Після успішної авторизації користувач потрапляє на сторінку свого облікового запису. Тут можна передивитися дані користувача, його історію покупок, відвідувань фітнес-клубів та тренажерних залів (див. рис.4.9), а також придбані абонементи (див. рис. 4.10).

 
Рисунок 4.9 – Обліковий запис користувача, історія відвідувань та покупок

 
Рисунок 4.10 – Обліковий запис користувача, придбані абонементи

Обліковий запис можна редагувати на відповідній сторінці, де можна змінювати ім’я, поштову скриньку, телефон, роль користувача, картку та пароль (див. рис. 4.11).

 
Рисунок 4.11 – Редагування облікового запису

З головної сторінки користувач також може потрапити на сторінку мережі тренажерних залів, де можемо знайти перелік тренажерних залів цієї мережі (див. рис. 4.12). Також присутня можливість пошуку та фільтрації по наявності потрібної зони тренажерного залу.

 
Рисунок 4.12 – Сторінка мережі тренажерних залів

Перейшовши на сторінку залу можна побачити всю інформацію про цей зал, а також доступні абонементи для покупки (див. рис. 4.13).

 
Рисунок 4.13 – Сторінка тренажерного залу

Якщо користувач авторизований, він може натиснути кнопку купити, обравши потрібний йому абонемент. Якщо користувач не авторизований, то у покупці йому буде відмовлено з проханням створити обліковий запис, або авторизуватися. Також, якщо користувач не має прив’язаної картки для оплати, йому запропонують її додати (див. рис. 4.14).

 
Рисунок 4.14 – Додання картки для оплати

Після чого картка додається до облікового запису користувача, а придбання абонементу підтверджується і він теж з’являється у обліковому записі користувача, а історія покупок оновлюється (див. рис. 4.15).

 
Рисунок 4.15 – Оновлений вигляд профілю користувача, після придбання абонементу

Тепер куплений абонемент можна сканувати на вході у тренажерний зал. Після натиснення на кнопку «Scan QRCode», інформація про користувача та його абонемент, що зберігається у ньому обробиться, у користувача оновляться його відвідування (див. рис. 4.16), а у мережі тренажерних залів – статистика. 
 
Рисунок 4.16 – Оновлення відвідувань користувача

Також можна експортувати дані про історію покупок користувача, а також про куплені абонементи, які будуть мати вигляд таблиць Excel з потрібними даними.

 
Рисунок 4.17 – Експорт даних історії покупок користувача

 
Рисунок 4.18 – Експорт даних про куплені абонементи

Було описано можливості взаємодії користувача з розробленою програмною системою.

4.3 Опис програмної реалізації для адміністратора


Сторінка реєстрації та авторизації для адміністратора аналогічні відповідним сторінкам для користувача. Адміністратор також має можливість передивлятись сторінки мережі тренажерних залів, кожного залу, але не може придбати абонемент. 
Сторінка облікового запису виглядає по-іншому. Є інформація про мережу залів, якою керує адміністратор, а також можливість редагувати профіль. Також у верхньому правому куті є можливість створити власну мережу, якщо вона ще не створена (див. рис. 4.19).

 
Рисунок 4.19 – Обліковий запис адміністратора

Створимо мережу тренажерних залів для цього адміністратора (див. рис. 4.20). Після чого мережа з’явиться на головній сторінці, а кнопку «Create company» замінить кнопка «Edit Company» (див. рис. 4.21).

  
Рисунок 4.20 – Створення мережі тренажерних залів

 
Рисунок 4.21 – Результат створення мережі залів

На сторінці редагування мережі залів можна змінити назву мережі, редагувати зали, та додавати нові зали (див. рис. 4.22).

 
Рисунок 4.22 – Сторінка редагування мережі залів

Під час редагування залу можна додавати та видаляти тренерів (див. рис. 4.23), додавати, редагувати та видаляти абонементи (див. рис. 4.24), додавати та видаляти тренажери (див. рис. 4.25), а також змінювати дані самого залу (див. рис. 4.26).

 
Рисунок 4.23 – Додавання тренера

 
Рисунок 4.24 – Редагування абонементу

 
Рисунок 4.25 – Додання тренажеру

 
Рисунок 4.26 – Редагування залу

Також є можливість передивитись усі відвідування залів мережі (див. рис. 4.27). 

 
Рисунок 4.27 – Відвідування мережі залів

При натисненні кнопки «Export to Excel» відбудеться експорт даних до таблиці Excel (див. рис. 4.28).

 
Рисунок 4.28 – Експорт даних відвідувань мережі

Було описано можливості взаємодії адміністратора з розробленою програмною системою. Для розширення розуміння функціоналу є посилання на відеоматеріали курсової роботи[5]. 
 
ВИСНОВКИ


За результатами виконання роботи було розроблено програмну систему організації та керування мережею фітнес клубів, басейнів.
Під час роботи було проаналізовано предметну область, було спроектовано базу даних, спроектовано серверну та клієнтську частину, а також частину смарт-пристрою, а також реалізовано засобами Node.js, express.js для серверної, React.js для клієнтської, а також Node-RED для смарт-пристрою.
Розроблена програмна система дозволяє користувачам обрати та придбати абонемент онлайн, та отримати власний QR-код для відвідувань фітнес-клубів та тренажерних залів. Програмна система надає можливості авторизації та реєстрації, а також створення та керування власною мережею тренажерних залів для адміністраторів. Програмна система зберігає інформацію про відвідування користувача для подальшої обробки та аналізу. Користувач може побачити власні відвідування, а також історію покупок. Користувач може експортувати дані про покупку, а також про придбані абонементи. Програмна система дозволяє адміністратору керувати власною мережею залів, самими залами та абонементами, а також експортувати дані про мережу залів.
 
ПЕРЕЛІК ДЖЕРЕЛ ПОСИЛАННЯ


1.	Node.js v20.3.1 Documentation. Node.js Documentation. URL: https://nodejs.org/dist/latest-v20.x/docs/api/ (дата звернення: 13.04.2024).
2.	Express - Node.js web application framework. Express.js Documentation. URL: https://expressjs.com/en/5x/api.html (дата звернення: 24.04.2024).
3.	React Reference Overview – React. URL: https://react.dev/reference/react (дата звернення: 12.05.2024).
4.	Design Patterns: Elements of Reusable Object-Oriented Software (Addison-Wesley Professional Computing Series) / R. Helm та ін. Addison-Wesley Professional, 1995. 395 р.
5.	Відеозапис курсової роботи, відеоматеріали реалізованого проекту. URL: https://youtu.be/nTN5iOJbweg
 
ДОДАТОК А
Програмний код серверної частини
А.1 Код основного файлу серверної частини app.js:


1 const express = require('express');
2 const mongoose = require('mongoose');
3 const dotenv = require('dotenv');
4 const cors = require('cors');
5 const bcrypt = require('bcryptjs');
6 
7 const userRouter = require('./routes/user');
8 const subRouter = require('./routes/subscription');
9 const gymRouter = require('./routes/gym');
10 const companyRouter = require('./routes/company');
11 const trainerRouter = require('./routes/trainer');
12 const purchaseRouter = require('./routes/purchase');
13 const visitRouter = require('./routes/visit');
14 const exportRouter = require('./routes/export');
15 
16 const authRouter = require('./routes/auth');
17 const auth = require('./middleware/auth');
18 
19 const Gym = require("./models/Gym");
20 const Visit = require("./models/Visit");
21 const User = require("./models/User");
22 const Subscription = require("./models/Subscription");
23 
24 dotenv.config();
25 
26 const app = express();
27 const port = process.env.PORT || 3001;
28 
29 mongoose.connect(process.env.MONGODB_URI)
30     .then(() => console.log('Connected to MongoDB'))
31     .catch(err => console.error('Could not connect to MongoDB', err));
32 
33 app.use(cors());
34 app.use(express.json());
35 
36 app.post('/scanQRCode', async (req, res) => {
37     try {
38         const { subscriptionId, userId } = req.body;
39 
40         const gym = await Gym.findOne({ subscriptions: { $in: [subscriptionId] } });
41 
42         if (!gym) {
43             return res.status(404).send({ error: 'Gym not found for this subscription' });
44         }
45 
46         const newVisit = new Visit({
47             gym: gym._id,
48             duration: 60,
49             date: new Date(),
50             user: userId,
51         });
52 
53         await User.findByIdAndUpdate(userId, { $push: { visits: newVisit._id } });
54 
55         await newVisit.save();
56         console.log('QR Code scanned:', req.body);
57         res.status(200).send({ message: 'QR Code scanned successfully' });
58     } catch (error) {
59         console.error('Error scanning QR Code:', error);
60         res.status(500).send({ error: 'Internal server error' });
61     }
62 });
63 
64 app.use('/', gymRouter);
65 app.use('/', companyRouter);
66 
67 app.use('/', authRouter);
68 
69 app.use('/', auth, exportRouter);
70 app.use('/', auth, userRouter);
71 app.use('/', auth, subRouter);
72 app.use('/', trainerRouter);
73 app.use('/', auth, purchaseRouter);
74 app.use('/', auth, visitRouter);
75 
76 app.listen(port, () => {
77     console.log(`Server is running on port ${port}`);
78 });


А.2 Код логіки покупки абонементу з файлу user.js


1 router.post('/user/sub', async (req, res) => {
2     try {
3         const { subscriptionId, userId } = req.body;
4 
5         await User.findByIdAndUpdate(userId, { $push: { subscription: subscriptionId } });
6 
7         const qrData = {
8             userId: userId,
9             subscriptionId: subscriptionId,
10         };
11 
12         const qrCodeData = await QRCode.toDataURL(JSON.stringify(qrData));
13 
14         const newQrCode = new QrCode({
15             userId: userId,
16             subscriptionId: subscriptionId,
17             qrCodeData: qrCodeData,
18         });
19 
20         await newQrCode.save();
21 
22         const newPurchase = new Purchase({
23             subscription: subscriptionId,
24             date: new Date(),
25         });
26 
27         await User.findByIdAndUpdate(userId, { $push: { purchaseHistory: newPurchase._id } });
28 
29         await newPurchase.save();
30 
31         res.status(200).send('Subscription purchased successfully');
32 
33     } catch (error) {
34         console.error('Error purchasing subscription:', error);
35         res.status(500).json({ message: 'Error purchasing subscription' });
36     }
37 });


А.3 Код зміни паролю для користувача з файлу user.js


1 router.put('/user/:id/change-password', async (req, res) => {
2     try {
3         const { currentPassword, newPassword } = req.body;
4         const user = await User.findById(req.params.id);
5 
6         if (!user) {
7             return res.status(404).json({ message: 'User not found' });
8         }
9 
10         const isMatch = await bcrypt.compare(currentPassword, user.password);
11         if (!isMatch) {
12             return res.status(400).json({ message: 'Current password is incorrect' });
13         }
14 
15         user.password = newPassword;
16         await user.save();
17 
18         res.json({ message: 'Password updated successfully' });
19     } catch (err) {
20         res.status(500).json({ message: err.message });
21     }
22 });


А.4 Код логіки експорту даних export.js


1 const express = require('express');
2 const mongoose = require('mongoose');
3 const router = express.Router();
4 const Gym = require("../models/Gym");
5 const User = require('../models/User');
6 const fs = require('fs');
7 const path = require('path');
8 const ExcelJS = require('exceljs');
9 const Visit = require("../models/Visit");
10 const Subscription = require("../models/Subscription");
11 
12 router.get('/export-purchase-history/:userId', async (req, res) => {
13     try {
14         const userId = req.params.userId;
15         console.log(`Exporting purchase history for user ID: ${userId}`);
16 
17         const user = await User.findById(userId).populate({path: 'purchaseHistory', populate: {path: 'subscription'}});
18 
19         if (!user) {
20             console.error(`User not found for ID: ${userId}`);
21             return res.status(404).send('User not found');
22         }
23 
24         if (user.purchaseHistory.length === 0) {
25             console.error(`No purchase history found for user ID: ${userId}`);
26             return res.status(404).send('No purchase history found');
27         }
28 
29         const workbook = new ExcelJS.Workbook();
30         const worksheet = workbook.addWorksheet('Purchase History');
31 
32         worksheet.columns = [
33             { header: 'Date', key: 'date', width: 20 },
34             { header: 'Product', key: 'product', width: 30 },
35             { header: 'Price', key: 'price', width: 15 },
36         ];
37 
38         user.purchaseHistory.forEach(purchase => {
39             worksheet.addRow({
40                 date: purchase.date,
41                 product: purchase.subscription.name,
42                 price: purchase.subscription.price,
43             });
44         });
45 
46         const dirPath = path.join(__dirname, 'temp');
47         if (!fs.existsSync(dirPath)){
48             fs.mkdirSync(dirPath);
49         }
50 
51         const filePath = path.join(dirPath, `purchase_history_${userId}.xlsx`);
52         await workbook.xlsx.writeFile(filePath);
53 
54         res.download(filePath, `purchase_history_${userId}.xlsx`, (err) => {
55             if (err) {
56                 console.error('Failed to download the file:', err.message);
57                 res.status(500).json({ message: 'Failed to download the file', error: err.message });
58             }
59             fs.unlinkSync(filePath);
60         });
61 
62     } catch (error) {
63         console.error('Error exporting purchase history:', error.message);
64         res.status(500).send(error.message);
65     }
66 });
67 
68 router.get('/subs-info/:userId/export', async (req, res) => {
69     try {
70         const userId = req.params.userId;
71         console.log(`Exporting subscriptions info for user ID: ${userId}`);
72 
73         const user = await User.findById(userId).populate({path:'subscription', populate: {path: 'coach'}});
74 
75         if (!user || !user.subscription || user.subscription.length === 0) {
76             console.error(`No subscriptions found for user ID: ${userId}`);
77             return res.status(404).send('No subscriptions found');
78         }
79 
80         const subscriptions = user.subscription;
81 
82         const workbook = new ExcelJS.Workbook();
83         const worksheet = workbook.addWorksheet('Subscriptions');
84 
85         worksheet.columns = [
86             { header: 'Name', key: 'name', width: 30 },
87             { header: 'Price', key: 'price', width: 15 },
88             { header: 'Duration', key: 'duration', width: 15 },
89             { header: 'Coach', key: 'coach', width: 30 },
90             { header: 'Action', key: 'action', width: 15 },
91         ];
92 
93         subscriptions.forEach(subscription => {
94             worksheet.addRow({
95                 name: subscription.name,
96                 price: subscription.price,
97                 duration: subscription.duration,
98                 coach: subscription.coach ? subscription.coach.name : 'Coach is not included',
99                 action: subscription.action
100             });
101         });
102 
103         const dirPath = path.join(__dirname, 'temp');
104         if (!fs.existsSync(dirPath)){
105             fs.mkdirSync(dirPath);
106         }
107 
108         const filePath = path.join(dirPath, `subs_info_${userId}.xlsx`);
109         await workbook.xlsx.writeFile(filePath);
110 
111         res.download(filePath, `subs_info_${userId}.xlsx`, (err) => {
112             if (err) {
113                 console.error('Failed to download the file:', err.message);
114                 res.status(500).json({ message: 'Failed to download the file', error: err.message });
115             }
116             fs.unlinkSync(filePath);
117         });
118 
119     } catch (error) {
120         console.error('Error exporting subscriptions info:', error.message);
121         res.status(500).send(error.message);
122     }
123 });
124 
125 module.exports = router;


A.5 Код запиту на створення нової мережі залів для певного адміністратора з файлу company.js


1 router.post('/company/:userId', [auth, admin, body('name').notEmpty().withMessage('Name is required')], async (req, res) => {
2     const errors = validationResult(req);
3     if (!errors.isEmpty()) {
4         return res.status(400).json({ errors: errors.array() });
5     }
6 
7     const company = new Company(req.body);
8 
9     try {
10         const newCompany = await company.save();
11 
12         if (!req.params.userId) {
13             return res.status(400).json({ message: 'User ID is not provided' });
14         }
15 
16         const updatedUser = await User.findByIdAndUpdate(
17             req.params.userId,
18             { company: newCompany._id },
19             { new: true }
20         );
21 
22         if (!updatedUser) {
23             return res.status(404).json({ message: 'User not found' });
24         }
25 
26         res.status(201).json(newCompany);
27     } catch (err) {
28         res.status(400).json({ message: err.message });
29     }
30 });


А.6 Код файлу для реєстрації та авторизації користувача auth.js


1 const express = require('express');
2 const router = express.Router();
3 const User = require('../models/user');
4 const bcrypt = require('bcryptjs');
5 const jwt = require('jsonwebtoken');
6 const { userValidationRules, validate } = require('../middleware/validators');
7 
8 router.post('/register', userValidationRules(), validate, async (req, res) => {
9     try {
10         const { name, email, password, role, phone, card, company } = req.body;
11 
12         const existingUser = await User.findOne({ email });
13         if (existingUser) {
14             return res.status(400).json({ message: 'User already exists' });
15         }
16 
17         const user = new User({ name, email, password, role, phone, card, company });
18         const newUser = await user.save();
19 
20         res.status(201).json({ message: 'User registered successfully', user: newUser });
21     } catch (err) {
22         res.status(400).json({ message: err.message });
23     }
24 });
25 
26 router.post('/login', async (req, res) => {
27     try {
28         const { email, password } = req.body;
29 
30         const user = await User.findOne({ email });
31         if (!user) {
32             return res.status(400).json({ message: 'Invalid email or password' });
33         }
34 
35         const isMatch = await bcrypt.compare(password, user.password);
36         if (!isMatch) {
37             return res.status(400).json({ message: 'Invalid email or password' });
38         }
39 
40         const token = jwt.sign({ userId: user._id, role: user.role }, process.env.JWT_SECRET, { expiresIn: '1h' });
41 
42         res.json({ token, userId: user._id, role: user.role });
43     } catch (err) {
44         res.status(400).json({ message: err.message });
45     }
46 });
47 
48 module.exports = router;
 
ДОДАТОК Б
Програмний код смарт-пристрою


1 [
2     {
3         "id": "c99a4a13771c2289",
4         "type": "tab",
5         "label": "Поток 1",
6         "disabled": false,
7         "info": "",
8         "env": []
9     },
10     {
11         "id": "3a10d3e20f295c46",
12         "type": "http in",
13         "z": "c99a4a13771c2289",
14         "name": "",
15         "url": "/scanQRCode",
16         "method": "post",
17         "upload": true,
18         "swaggerDoc": "",
19         "x": 90,
20         "y": 300,
21         "wires": [
22             [
23                 "d1a9b3601312c354"
24             ]
25         ]
26     },
27     {
28         "id": "3e619d4471c97980",
29         "type": "http request",
30         "z": "c99a4a13771c2289",
31         "name": "",
32         "method": "POST",
33         "ret": "txt",
34         "paytoqs": "ignore",
35         "url": "http://localhost:3001/scanQRCode",
36         "tls": "",
37         "persist": false,
38         "proxy": "",
39         "insecureHTTPParser": false,
40         "authType": "",
41         "senderr": false,
42         "headers": [
43             {
44                 "keyType": "Content-Type",
45                 "keyValue": "",
46                 "valueType": "application/json",
47                 "valueValue": ""
48             }
49         ]
50         "x": 1690,
51         "y": 300,
52         "wires": [
53             []
54         ]
55     },
56     {
57         "id": "d1a9b3601312c354",
58         "type": "function",
59         "z": "c99a4a13771c2289",
60         "name": "function 2",
61         "func": "msg.payload = msg.payload.qrCode;\nreturn msg;\n",
62         "outputs": 1,
63         "timeout": 0,
64         "noerr": 0,
65         "initialize": "",
66         "finalize": "",
67         "libs": [],
68         "x": 320,
69         "y": 300,
70         "wires": [
71             [
72                 "f4d61cba0948d7cf"
73             ]
74         ]
75     },
76     {
77         "id": "f4d61cba0948d7cf",
78         "type": "function",
79         "z": "c99a4a13771c2289",
80         "name": "function 3",
81         "func": "const base64Prefix = 'data:image/png;base64,';\nif (msg.payload.startsWith(base64Prefix)) {\n    msg.payload = msg.payload.slice(base64Prefix.length);\n}\nreturn msg;\n\n",
82         "outputs": 1,
83         "timeout": 0,
84         "noerr": 0,
85         "initialize": "",
86         "finalize": "",
87         "libs": [],
88         "x": 540,
89         "y": 300,
90         "wires": [
91             [
92                 "fac913488d1014d4"
93             ]
94         ]
95     },
96     {
97         "id": "fac913488d1014d4",
98         "type": "base64",
99         "z": "c99a4a13771c2289",
100         "name": "",
101         "action": "",
102         "property": "payload",
103         "x": 780,
104         "y": 300,
105         "wires": [
106             [
107                 "695fb134a963e402"
108             ]
109         ]
110     },
111     {
112         "id": "695fb134a963e402",
113         "type": "qrdecode",
114         "z": "c99a4a13771c2289",
115         "name": "",
116         "x": 1020,
117         "y": 300,
118         "wires": [
119             [
120                 "24d695f2cd13dee0"
121             ]
122         ]
123     },
124     {
125         "id": "24d695f2cd13dee0",
126         "type": "json",
127         "z": "c99a4a13771c2289",
128         "name": "",
129         "property": "payload.value",
130         "action": "",
131         "pretty": false,
132         "x": 1290,
133         "y": 300,
134         "wires": [
135             [
136                 "46ef88ad2df051a3"
137             ]
138         ]
139     },
140     {
141         "id": "46ef88ad2df051a3",
142         "type": "function",
143         "z": "c99a4a13771c2289",
144         "name": "function 4",
145         "func": "msg.payload = {\n    subscriptionId: msg.payload.value.subscriptionId,\n    userId: msg.payload.value.userId\n};\nreturn msg;",
146         "outputs": 1,
147         "timeout": 0,
148         "noerr": 0,
149         "initialize": "",
150         "finalize": "",
151         "libs": [],
152         "x": 1480,
153         "y": 300,
154         "wires": [
155             [
156                 "3e619d4471c97980"
157             ]
158         ]
159     }
160 ]
 
ДОДАТОК В
Програмний код клієнтської частини
В.1 Код шапки сайту з визначенням ролі користувача Header.js


1 import React, { useState, useEffect } from 'react';
2 import { Link, useLocation } from 'react-router-dom';
3 import { jwtDecode } from "jwt-decode";
4 import './Header.css';
5 import axios from "axios";
6 
7 function Header() {
8     const [userId, setUserId] = useState(null);
9     const [companyId, setCompanyId] = useState(null);
10     const [userRole, setUserRole] = useState('user');
11     const [isAuthenticated, setIsAuthenticated] = useState(false);
12     const location = useLocation();
13 
14     useEffect(() => {
15         const token = localStorage.getItem('token');
16         if (token) {
17             const decodedToken = jwtDecode(token);
18             setUserId(decodedToken.userId);
19             setUserRole(decodedToken.role);
20             const fetchUserData = async () => {
21                 try {
22                     const headers = { Authorization: `Bearer ${token}` };
23                     const response = await axios.get(`http://localhost:3001/user/${userId}`, {headers});
24                     const user = response.data;
25                     console.log(user);
26                     setUserRole(user.role);
27                     setCompanyId(user.company._id);
28                 } catch (error) {
29                     console.error('Error fetching user data:', error);
30                 }
31             };
32             if(userRole === 'admin') fetchUserData();
33             setIsAuthenticated(true);
34         } else {
35             setIsAuthenticated(false);
36         }
37     }, [location.pathname, userId, userRole]);
38 
39 
40     return (
41         <header className="header">
42             <Link to="/" className="header-title">SportSync</Link>
43             <div className="header-auth">
44                 {isAuthenticated ? (
45                     <>
46                         <Link to={`/user/${userId}`} className="header-link">Profile</Link>
47                         {userRole === 'admin' && companyId && (
48                             <Link to={`/company/${companyId}/edit`} className="header-link">Edit Company</Link>
49                         )}
50                         {userRole === 'admin' && !companyId && (
51                             <Link to={`/company/create`} className="header-link">Create Company</Link>
52                         )}
53                     </>
54                 ) : (
55                     <>
56                         <Link to="/login" className="header-link">Login</Link>
57                         <Link to="/register" className="header-link">Register</Link>
58                     </>
59                 )}
60             </div>
61         </header>
62     );
63 }
64 
65 export default Header;





В.2 Код сторінки залу з логікою придбання абонементу GymPage.js


1 import React, { useState, useEffect } from 'react';
2 import axios from 'axios';
3 import { useParams } from 'react-router-dom';
4 import { jwtDecode } from 'jwt-decode';
5 import './GymPage.css';
6 
7 function GymPage() {
8     const { gymId } = useParams();
9     const [gym, setGym] = useState(null);
10     const [loading, setLoading] = useState(true);
11     const [isModalOpen, setIsModalOpen] = useState(false);
12     const [isCardModalOpen, setIsCardModalOpen] = useState(false);
13     const [selectedSubscription, setSelectedSubscription] = useState(null);
14     const [cardDetails, setCardDetails] = useState({ cardNumber: '', cardName: '', expiryDate: '', cvv: '' });
15 
16     useEffect(() => {
17         const fetchGym = async () => {
18             try {
19                 const response = await axios.get(`http://localhost:3001/gym/${gymId}`);
20                 setGym(response.data);
21                 setLoading(false);
22             } catch (error) {
23                 console.error('Error fetching gym:', error);
24                 setLoading(false);
25             }
26         };
27 
28         fetchGym();
29     }, [gymId]);
30 
31     const handleBuyClick = (subscription) => {
32         setSelectedSubscription(subscription);
33         setIsModalOpen(true);
34     };
35 
36     const handleConfirmPurchase = async () => {
37         const token = localStorage.getItem('token');
38         if (token) {
39             const decodedToken = jwtDecode(token);
40             const userId = decodedToken.userId;
41             try {
42                 const headers = { Authorization: `Bearer ${token}` };
43 
44                 const userResponse = await axios.get(`http://localhost:3001/user/${userId}`, { headers });
45                 const user = userResponse.data;
46 
47                 if (user.card) {
48                     const response = await axios.post(`http://localhost:3001/user/sub`, {
49                         subscriptionId: selectedSubscription._id,
50                         userId: userId,
51                     }, { headers });
52                     alert('Subscription purchased:', response.data);
53                     setIsModalOpen(false);
54                 } else {
55                     setIsModalOpen(false);
56                     setIsCardModalOpen(true);
57                 }
58             } catch (error) {
59                 console.error('Error purchasing subscription:', error);
60             }
61         } else {
62             alert('You need to be logged in to make a purchase.');
63         }
64     };
65 
66     const handleAddCard = async () => {
67         const token = localStorage.getItem('token');
68         if (token) {
69             const decodedToken = jwtDecode(token);
70             const userId = decodedToken.userId;
71             try {
72                 const headers = { Authorization: `Bearer ${token}` };
73                 await axios.post(`http://localhost:3001/user/${userId}/addCard`, cardDetails, { headers });
74                 setIsCardModalOpen(false);
75                 alert('Card added successfully.');
76                 handleConfirmPurchase();
77             } catch (error) {
78                 console.error('Error adding card:', error);
79             }
80         }
81     };
82 
83     const handleCloseModal = () => {
84         setIsModalOpen(false);
85     };
86 
87     const handleCloseCardModal = () => {
88         setIsCardModalOpen(false);
89     };
90 
91     const handleCardDetailsChange = (e) => {
92         const { name, value } = e.target;
93         setCardDetails({ ...cardDetails, [name]: value });
94     };
95 
96     if (loading) return <p>Loading...</p>;
97     if (!gym) return <p>Gym not found</p>;
98 
99     return (
100         <div className='wrapper'>
101             <div className="gym-container">
102                 <h2 className="gym-name">{gym.address}</h2>
103                 <p className="gym-address">Company: {gym.company.name}</p>
104                 <h3>Zones</h3>
105                 <ul>
106                     {gym.zones.map((zone, index) => (
107                         <li key={index}>{zone}</li>
108                     ))}
109                 </ul>
110             </div>
111             <h3>Trainers List</h3>
112             <div className="trainers-container">
113                 <ul>
114                     {gym.trainersList.map((trainer, index) => (
115                         <li key={index}>{trainer.name}</li>
116                     ))}
117                 </ul>
118             </div>
119             <h3>Coaches List</h3>
120             <div className="coaches-container">
121                 <ul>
122                     {gym.coachesList.map((coach, index) => (
123                         <li key={index}>{coach.name}</li>
124                     ))}
125                 </ul>
126             </div>
127             <h3>Subscriptions</h3>
128             <div className="subs-container">
129                 <ul>
130                     {gym.subscriptions.map((subscription, index) => (
131                         <li key={index}>
132                             <h4>{subscription.name}</h4>
133                             <p>Price: {subscription.price}$</p>
134                             <p>Coach: {subscription.coach ? subscription.coach.name : 'Coach is not included'}</p>
135                             <p>Duration: {subscription.duration} days</p>
136                             <p>Action: {subscription.action}%</p>
137                             <button onClick={() => handleBuyClick(subscription)}>Buy</button>
138                         </li>
139                     ))}
140                 </ul>
141             </div>
142 
143             {isModalOpen && (
144                 <div className="modal">
145                     <div className="modal-content">
146                         <h2>Confirm Purchase</h2>
147                         <p>Are you sure you want to buy the subscription "{selectedSubscription.name}" for {selectedSubscription.price}$?</p>
148                         <button onClick={handleConfirmPurchase}>Confirm</button>
149                         <button onClick={handleCloseModal}>Cancel</button>
150                     </div>
151                 </div>
152             )}
153 
154             {isCardModalOpen && (
155                 <div className="modal">
156                     <div className="modal-content">
157                         <h2>Add Card</h2>
158                         <form className='modal-form-card'>
159                             <label>
160                                 Card Number:
161                                 <input type="text" name="cardNumber" value={cardDetails.cardNumber} onChange={handleCardDetailsChange} />
162                             </label>
163                         </form>
164                         <button onClick={handleAddCard}>Add Card</button>
165                         <button onClick={handleCloseCardModal}>Cancel</button>
166                     </div>
167                 </div>
168             )}
169         </div>
170     );
171 }
172 
173 export default GymPage;

В.3 Код сторінки облікового запису Profile.js


1 import React, { useState, useEffect } from 'react';
 2 import axios from 'axios';
 3 import { useParams, useNavigate } from 'react-router-dom';
 4 import './Profile.css';
 5 import QRCode from 'qrcode.react';
 6 
 7 function isAdmin(user, qrs) {
 8     const handleScanQRCode = async (subId, userId, qrCode) => {
 9         try {
10             const response = await axios.post('http://localhost:1880/scanQRCode', {
11                 qrCode: qrCode,
12             });
13             console.log('QR Code scanned:', response.data);
14         } catch (error) {
15             console.error('Error scanning QR Code:', error);
16         }
17     };
18 
19     if (user.role === 'admin') {
20         return (
21             <>
22                 <div className="visits-container">
23                     <label>Company</label>
24                     <p>{user.company ? user.company.name : '-'}</p>
25                 </div>
26             </>
27         );
28     } else if (user.role === 'user') {
29         return (
30             <div className='profile-info'>
31                 <div className="visits-container">
32                     <label>Visits</label>
33                     {user.visits &&
34                         user.visits.map((visit, index) => (
35                             <p key={index}>
36                                 {visit.gym.address}, {new Date(visit.date).toLocaleString()}
37                             </p>
38                         ))}
39                 </div>
40                 <div className="purchase-history-container">
41                     <label>Purchase History</label>
42                     {user.purchaseHistory &&
43                         user.purchaseHistory.map((purchase, index) => (
44                             <p key={index}>
45                                 {purchase.subscription.name}, {purchase.subscription.price}$, {new Date(purchase.date).toLocaleString()}
46                             </p>
47                         ))}
48                 </div>
49                 <div className="card-container">
50                     <label>Card</label>
51                     <p>{user.card || '-'}</p>
52                 </div>
53                 <div className="sub-container">
54                     <label>Subscriptions</label>
55                     <ul>
56                         {user.subscription &&
57                             user.subscription.map((subscription, index) => (
58                                 <li key={index}>
59                                     <h4>{subscription.name}</h4>
60                                     <p>Price: {subscription.price}$</p>
61                                     <p>Coach: {subscription.coach ? subscription.coach.name : 'Coach is not included'}</p>
62                                     <p>Duration: {subscription.duration} days</p>
63                                     <p>Action: {subscription.action}%</p>
64                                     <p>QRCode:</p>
65                                     <div>{getQRcode(qrs, subscription._id, user._id) ? <QRCode value={getQRcode(qrs, subscription._id, user._id).qrCodeData} /> : '-'}</div>
66                                     <button onClick={() => handleScanQRCode(subscription._id, user._id, getQRcode(qrs, subscription._id, user._id).qrCodeData)}>Scan QRCode</button>
67                                 </li>
68                             ))}
69                     </ul>
70                 </div>
71             </div>
72         );
73     }
74 }
75 
76 function getQRcode(qrCodes, subId, userId) {
77     if (!Array.isArray(qrCodes)) {
78         throw new Error('First argument must be an array');
79     }
80     if (!subId || !userId) {
81         throw new Error('Both subId and userId are required');
82     }
83 
84     const qrCode = qrCodes.find(
85         (qrCode) => qrCode.subscriptionId.toString() === subId.toString() && qrCode.userId.toString() === userId.toString()
86     );
87 
88     return qrCode || null;
89 }
90 
91 function Profile() {
92     const { userId } = useParams();
93     const [user, setUser] = useState(null);
94     const [loading, setLoading] = useState(true);
95     const [qrs, setQrs] = useState([]);
96     const [showConfirmation, setShowConfirmation] = useState(false);
97     const navigate = useNavigate();
98 
99     useEffect(() => {
100         const fetchProfile = async () => {
101             try {
102                 const token = localStorage.getItem('token');
103                 const headers = { Authorization: `Bearer ${token}` };
104                 const response = await axios.get(`http://localhost:3001/user/${userId}`, { headers });
105                 const qrResponse = await axios.get(`http://localhost:3001/qrs`, { headers });
106                 setUser(response.data);
107                 setQrs(qrResponse.data);
108                 setLoading(false);
109             } catch (error) {
110                 console.error('Error fetching profile:', error);
111                 setLoading(false);
112             }
113         };
114 
115         fetchProfile();
116     }, [userId]);
117 
118     const exportPurchaseHistory = async () => {
119         try {
120             const token = localStorage.getItem('token');
121             const headers = { Authorization: `Bearer ${token}` };
122             const response = await axios.get(`http://localhost:3001/export-purchase-history/${userId}`, {
123                 headers,
124                 responseType: 'blob',
125             });
126 
127             const blob = new Blob([response.data], { type: 'application/vnd.openxmlformats-officedocument.spreadsheetml.sheet' });
128 
129             const url = window.URL.createObjectURL(blob);
130             const a = document.createElement('a');
131             a.href = url;
132             a.download = `purchase_history_${userId}.xlsx`;
133             document.body.appendChild(a);
134             a.click();
135             document.body.removeChild(a);
136             window.URL.revokeObjectURL(url);
137         } catch (error) {
138             console.error('Error exporting purchase history:', error);
139         }
140     };
141 
142     const exportSubscriptions = async () => {
143         try {
144             const token = localStorage.getItem('token');
145             const headers = { Authorization: `Bearer ${token}` };
146             const response = await axios.get(`http://localhost:3001/subs-info/${userId}/export`, {
147                 headers,
148                 responseType: 'blob',
149             });
150 
151             const blob = new Blob([response.data], { type: 'application/vnd.openxmlformats-officedocument.spreadsheetml.sheet' });
152 
153             const url = window.URL.createObjectURL(blob);
154             const a = document.createElement('a');
155             a.href = url;
156             a.download = `subs_info_${userId}.xlsx`;
157             document.body.appendChild(a);
158             a.click();
159             document.body.removeChild(a);
160             window.URL.revokeObjectURL(url);
161         } catch (error) {
162             console.error('Error exporting subscriptions info:', error);
163         }
164     };
165 
166     const handleDeleteAccount = async () => {
167         try {
168             const token = localStorage.getItem('token');
169             const headers = { Authorization: `Bearer ${token}` };
170             await axios.delete(`http://localhost:3001/user/${userId}`, { headers });
171             localStorage.removeItem('token');
172             navigate('/login');
173         } catch (error) {
174             console.error('Error deleting account:', error);
175         }
176     };
177 
178     const toggleConfirmation = () => {
179         setShowConfirmation(!showConfirmation);
180     };
181 
182     const handleLogout = () => {
183         localStorage.removeItem('token');
184         navigate('/login');
185     };
186 
187     if (loading) return <p>Loading...</p>;
188     if (!user) return <p>User not found</p>;
189 
190     return (
191         <div className="profile-container">
192             <div className="profile-header">
193                 <h2 className="profile-name">{user.name}</h2>
194                 <p className="profile-email">{user.email}</p>
195             </div>
196             <div className="profile-details">
197                 <div className="profile-detail">
198                     <label>Phone</label>
199                     <p>{user.phone || '-'}</p>
200                 </div>
201                 <div className="profile-detail">
202                     <label>Role</label>
203                     <p>{user.role}</p>
204                 </div>
205             </div>
206             {isAdmin(user, qrs)}
207             <div className="profile-actions">
208                 {user.role === 'user' && (
209                     <>
210                         <button className="export-button" onClick={exportPurchaseHistory}>
211                             Export Purchase History
212                         </button>
213                         <button className="export-button" onClick={exportSubscriptions}>
214                             Export Subscriptions Info
215                         </button>
216                     </>
217                 )}
218                 <button className="profile-action-button" onClick={() => navigate(`/user/${userId}/edit`)}>
219                     Edit Profile
220                 </button>
221                 <button className="delete-button" onClick={toggleConfirmation}>
222                     Delete Account
223                 </button>
224                 <button className="delete-button" onClick={handleLogout}>
225                     Logout
226                 </button>
227             </div>
228             {showConfirmation && (
229                 <div className="confirmation-modal">
230                     <p>Are you sure you want to delete your account?</p>
231                     <div className="confirmation-buttons">
232                         <button onClick={handleDeleteAccount}>Yes</button>
233                         <button onClick={toggleConfirmation}>No</button>
234                     </div>
235                 </div>
236             )}
237         </div>
238     );
239 }
240 
241 export default Profile;
